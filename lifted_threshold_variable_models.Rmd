---
title: "Lifted Threshold Variable Models"
author: "Erin Bennett"
output:
  pdf_document:
    toc: true
    highlight: zenburn
---

```{r, echo=FALSE}
# install dependencies
library(ggplot2, quiet=T)
library(plyr, quiet=T)
source("~/opt/r_helper_scripts/bootsSummary.r")

marginalize = function(df) {
  value_df = ddply(df,
                   .(alternatives, prior_distribution, cost_of_adjective,
                     utterance, speaker_lambda, value, resample_number),
                   summarize,
                   probability = sum(probability))
  theta_df = ddply(df,
                   .(alternatives, prior_distribution, cost_of_adjective,
                     utterance, speaker_lambda, theta, resample_number),
                   summarize,
                   probability = sum(probability))
  value_df$variable = "value"
  theta_df$variable = "theta"
  names(theta_df)[names(theta_df) == "theta"] = "value"
  value_df$variable = factor(value_df$variable, levels=c("value", "theta"))
  theta_df$variable = factor(theta_df$variable, levels=c("value", "theta"))
  new_df = rbind(value_df, theta_df)
  return(new_df)
  }
```

# RSA: Inferred Threshold

## Math

Literal Listener's probability distribution over the values $X$ are is prior, conditioned on the utterance being true and renormalized.

$$P_{L0}(x | u, \theta) \propto \delta_{u \mbox{ is true}} \cdot P(x)$$

Speaker's utility is the negative cost and the log probability of the actual state of the world under the Literal Listener's posterior. This means that the more surprised the Literal Listener would be to hear the true state of the world after already hearing the utterance, the less good the utterance would be.

$$\mathbb{U}_{S}(u | x, \theta) = log(P_{L0}(x|u, \theta)) - cost(u)$$

The speaker then chooses an utterance by soft-maximizing their utility funciton.

$$P_{S}(u|x, \theta) \propto e^{\lambda \mathbb{U}_{S}(u|x, \theta)}$$

The pragmatic listener infers both the threshold $\theta$ and the value $x$ conditioning on the speaker choosing the given utterance.

$$P_{L1}(x, \theta | u) \propto P_{S}(u|x, \theta)P(x)P(\theta)$$

## Code (WebPPL)

```
var literal_listener = cache(function(utterance, theta) {
  Enumerate(function() {
		var value = value_prior();
		factor(meaning(utterance, theta, value) ? 0 : -Infinity);
		return value;
	})
})

var speaker = cache(function(value, theta) {
	Enumerate(function() {
		var utterance = utterance_prior();
		var literal_interpretation = literal_listener(utterance, theta);
		factor(literal_interpretation.score([], value) * speaker_lambda);
		return utterance;
	})
})

var listener = function(utterance) {
	var value = value_prior();
	var theta = theta_prior();
	var speaker_choice = speaker(value, theta);
	factor(speaker_choice.score([], utterance));
	return [value, theta];
}
```

# Model Simulations for Some Theoretical Prior Distributions

## Priors

I looked at several different prior distributions on the bounded interval [0,1]:

* (bounded) normal: $\delta_{[0,1]} \cdot \mathcal{N}(0.5, 0.1)$
* uniform: $\mathcal{U}(0, 1)$
* betas:
* $\mbox{Beta}(1, 5)$
* $\mbox{Beta}(5, 1)$
* (bounded) log-normal:
* $\delta_{[0,1]} \cdot \ln \mathcal{N}(-1, 0.3)$
* reversed: $\delta_{[0,1]} \cdot \ln \mathcal{N}(1-x ; -1, 0.3)$
* linear:
* $2-2x$
* $2x$

These distributions were discretized for the simulations.

```{r, echo=FALSE, fig.width=7, fig.height=3}
x = seq(from=0, to=1, by=0.01)
dists = list(
  list("normal", dnorm(x, mean=0.5, sd=0.1))
  , list("uniform", dunif(x, 0, 1))
  , list("beta(1, 5)", dbeta(x, 1, 5))
  , list("beta(5, 1)", dbeta(x, 5, 1))
  , list("lognormal(-1, 0.3)", dlnorm(x, meanlog=-1, sdlog=0.3))
  , list("lognormal(1-x, -1, 0.3)", dlnorm(1-x, meanlog=-1, sdlog=0.3))
  , list("2-2x", 2-2*x)
  , list("2x", 2*x)
  )
d = data.frame(x=c(rep(x, length(dists))),
               y=unlist(sapply(dists, function(lst) {return(lst[2])})),
               dist=c(sapply(dists, function(lst) {return(rep(lst[[1]], length(x)))})))

### graph distributions:
p = ggplot(d, aes(x=x, y=y, colour=dist, fill=dist)) +
  geom_line(lwd=1) +
  theme_bw(12) +
  theme(panel.grid=element_blank()) +
  ggtitle("Various Bounded Continuous Priors")
print(p)

# ## to print prior distributions for webppl input:
# dist_data = data.frame(
#   type=c(rep("x", length(x)),
#          unlist(sapply(dists, function(dist) {return(rep(dist[[1]], length(x)))}))),
#   probability=c(x,
#                 sapply(dists, function(dist) {return(dist[[2]])}))
# )
# write.table(dist_data, sep=",", row.names=F, col.names=F, file="data/input/toy_priors.csv")
```

## Simulation Results

```{r, echo=F, fig.width=8.5, fig.height=6}
# ### need to modify this
# webppl_output = rbind(
#   read.table("data/output/toy_priors/normal.csv", sep=",", header=T)
#   , read.table("data/output/toy_priors/uniform.csv", sep=",", header=T)
#   , read.table("data/output/toy_priors/beta1_5.csv", sep=",", header=T)
#   , read.table("data/output/toy_priors/beta5_1.csv", sep=",", header=T)
#   , read.table("data/output/toy_priors/lognormal1-x_-1_0.3.csv", sep=",", header=T)
#   , read.table("data/output/toy_priors/lognormal-1_0.3.csv", sep=",", header=T)
#   , read.table("data/output/toy_priors/2x.csv", sep=",", header=T)
#   , read.table("data/output/toy_priors/2-2x.csv", sep=",", header=T)
#   )
# webppl_output$prior_distribution = factor(webppl_output$prior_distribution,
#                                           levels=c(
#                                             "2-2x",
#                                             "2x",
#                                             "beta0.1_0.1",
#                                             "beta1_5",
#                                             "beta5_1",
#                                             "lognormal-1_0.3",
#                                             "lognormal1-x_-1_0.3",
#                                             "normal",
#                                             "uniform"
#                                             ), labels=c(
#                                               "2-2x",
#                                               "2x",
#                                               "beta(0.1,0.1)",
#                                               "beta(1, 5)",
#                                               "beta(5, 1)",
#                                               "lognormal(-1, 0.3)",
#                                               "lognormal(1-x, -1, 0.3)",
#                                               "normal",
#                                               "uniform"
#                                               ))
# webppl_output$probability = as.numeric(as.character(webppl_output$probability))
# 
# webppl_output$resample_number = 1
# marginalized_output = marginalize(webppl_output)
# write.table(marginalized_output, "data/input/marginalized_output.csv", row.names=F, sep=",")
marginalized_output = read.table("data/input/marginalized_output.csv", header=T, sep=",")

theta_output = subset(marginalized_output, (utterance == "prior" & variable == "value") |
                        (utterance == "adjective" & variable == "theta"))
theta_output$group = "prior"
theta_output$group[theta_output$variable == "theta"] = "posterior_theta"

# p = ggplot(theta_output, aes(x=value, y=probability, linetype=paste(cost_of_adjective, speaker_lambda),
#                              colour=prior_distribution)) +
#   geom_line(lwd=0.7) +
#   facet_wrap(~ prior_distribution, scale="free") +
#   theme_bw(10) +
#   theme(panel.grid=element_blank()) +
#   ggtitle("WebPPL output for theta posterior with various parameters")
# print(p)

marginalized_output$parameters = factor(paste("lambda",
                                              marginalized_output$speaker_lambda,
                                              "; cost",
                                              marginalized_output$cost_of_adjective))
marginalized_output$variable = factor(marginalized_output$variable, levels=c("value", "theta"))
p = ggplot(subset(marginalized_output, utterance == "adjective"),
           aes(x=value, y=probability, linetype=variable,
               colour=parameters)) +
  geom_line() +
  geom_line(data=subset(marginalized_output, utterance == "prior" & speaker_lambda ==1 & cost_of_adjective == 1
                        & variable == "value"),
            aes(x=value, y=probability), colour="black") +
  facet_wrap(~ prior_distribution, scale="free")
print(p)
```

