//node --max-old-space-size=8192 ~/cocolab/webppl/webppl adjectives.wppl --require-js ./simpleCSV.js 

// possible dimensions of variation:
// what alternatives are possible?
//    - say nothing: ""
//    - say adjective: "adjective"
//    - negate adjective: "~adjective"
//    - say opposite of adjective: "opposite"
//    - negate opposite of adjective: "~opposite"
//    - communicate exactly: "exact"
// cost of adjective/~adjective/opposite/~opposite
//    - prior will then be e^(-cost)
// prior distribution over values along the adjective scale
// is theta lifted?
//    - does the literal listener infer theta?
//    - or the pragmatic listener?
// rationality parameter lambda
// softmax?

// var version = "anthea";
var version = "toy";

var priors = simpleCSV.readCSV("data/input/" + version + "_priors.csv");

var get_prior_values = function(value_type) {
	return map(
		function(row) {return global.parseFloat(row[1]);},
		filter(function(row) {return row[0] == value_type;},priors.data)
	);
}

var values = get_prior_values("x");

var probabilities = version == "toy" ? {
		"normal": get_prior_values("normal"),
		"uniform": get_prior_values("uniform"),
		"beta5_1": get_prior_values("beta(5, 1)"),
		"beta1_5": get_prior_values("beta(1, 5)"),
		"lognormal-1_0.3": get_prior_values("lognormal(-1, 0.3)"),
		"lognormal1-x_-1_0.3": get_prior_values("lognormal(1-x, -1, 0.3)"),
		"2-2x": get_prior_values("2-2x"),
		"2x": get_prior_values("2x")
	} : {
		"bas": get_prior_values("bas"),
		"book": get_prior_values("book"),
		"bur": get_prior_values("bur"),
		"cig": get_prior_values("cig"),
		"eat": get_prior_values("eat"),
		"edu": get_prior_values("edu"),
		"girl": get_prior_values("girl"),
		"hair": get_prior_values("hair"),
		"kid": get_prior_values("kid"),
		"mov": get_prior_values("mov"),
		"move": get_prior_values("move"),
		"poem": get_prior_values("poem"),
		"shoe": get_prior_values("shoe"),
		"trav": get_prior_values("trav"),
		"tv": get_prior_values("tv")
	};

var utterances = {
	"pos_neg_null_exact": ["adjective", "", "~adjective", "exact"],
	"pos_neg_null": ["adjective", "", "~adjective"],
	"pos_null": ["adjective", ""],
	"pos": ["adjective"],
	"pos_opp_null": ["adjective", "opposite", ""],
	"pos_neg_opp_null": ["adjective", "~adjective", "opposite", "~opposite", ""],
}

var get_costs = cache(function(cost_value) {
	return {
		"adjective": cost_value
		, "~adjective": cost_value
		, "": 0 //null utterance (always true) is free
		, "exact": Infinity //exact communication is infinitely costly
	}
})

var get_utterance_prior = function(cost_value, alternatives_value) {
	var costs = get_costs(cost_value);
	var utts = utterances[alternatives_value];
	var probs_of_utts = map(function(utt) {return Math.pow(Math.E, - costs[utt])}, utts);

	return function() {
		return utts[discrete(probs_of_utts)];
	}
}

var meaning = function(utterance, theta, value, opposite_theta) {
	if (utterance == "adjective") {
		return value >= theta;
	} else if (utterance == "~adjective") {
		return value <= theta;
	} else if (utterance == "opposite") {
		return value <= opposite_theta;
	} else if (utterance == "~opposite") {
		return value >= opposite_theta;
	} else if (utterance == "") {
		return true;
	}
}

var getHist = function(dist) {
	var probs = map(function(label) {return Math.exp(dist.score([], label))}, dist.support([]));
	var pairList = zip(dist.support([]), probs);
	return pairList;
}

var model = function(speaker_lambda, which_alternatives, which_distribution, which_cost, is_theta_lifted) {

	// the adjective "opposite" means the opposite of the adjective. so if the adjective is "tall"
	// the opposite is "short". the opposite should have its own theta, whereas "~adjective"
	// (roughly "not tall") uses the same theta as the adjective.
	var need_opposite_theta = utterances[which_alternatives].indexOf("opposite") >= 0;

	var theta_prior = function() {
		return uniformDraw(values);
	}

	var value_prior = function() {
		return values[discrete(probabilities[which_distribution])];
	}

	var utterance_prior = get_utterance_prior(which_cost, which_alternatives);

	var literal_listener = cache(function(utterance, theta, opposite_theta) {
		Enumerate(function() {
			var theta = theta ? theta : theta_prior();
			var opposite_theta = opposite_theta ? opposite_theta : -1;
			var value = value_prior();
			factor(meaning(utterance, theta, value) ? 0 : -Infinity);
			return value;
		})
	})

	var speaker = cache(function(value, theta, opposite_theta) {
		Enumerate(function() {
			var utterance = utterance_prior();
			var literal_interpretation = literal_listener(utterance, theta, opposite_theta);
			var score = literal_interpretation.score([], value);
			factor(score * speaker_lambda);
			return utterance;
		})
	})

	var listener = function(utterance, prior) {
		var value = value_prior();
		var theta = theta_prior();
		if (utterance != "prior") {
			var speaker_choice = speaker(value, theta);
			var score = speaker_choice.score([], utterance);
			factor(score);
		}
		return [value, theta];
	}

	var adjective_posterior = map(
		function(post_pair) {return post_pair.concat(["adjective"]);},
		getHist(Enumerate(function() {return listener("adjective")}))
	);
	var prior = map(
		function(post_pair) {return post_pair.concat(["prior"]);},
		getHist(Enumerate(function() {return listener("prior")}))
	);
	var results = adjective_posterior.concat(prior);

	//turn into a format that goes nicely into a csv file
	return  map(function(post_pair) {return [
				post_pair[0][0], //value
				post_pair[0][1], //theta
				post_pair[1] //probability
				, which_alternatives
				, which_distribution
				, which_cost
				, post_pair[2] //utterance
				, speaker_lambda
			];}, results);
}

var prior_distribution_types = version == "toy" ? [
		"normal",
		"uniform",
		"beta5_1",
		"beta1_5",
		"lognormal-1_0.3",
		"lognormal1-x_-1_0.3",
		"2-2x",
		"2x"
	] : [
		"bas", "book", "bur", "cig", "eat", "edu", "girl",
		"hair", "kid", "mov", "move", "poem", "shoe", "trav", "tv"
	];
var alphas = [1, 5];
var costs_of_adjective = [1, 6];

map(function(prior_distribution_type) {
	var model_output = [[
		"value",
		"theta",
		"probability",
		"alternatives",
		"prior_distribution",
		"cost_of_adjective",
		"utterance",
		"speaker_lambda"
	]].concat(
		reduce(function(cost_of_adjective, output_so_far) {
			return output_so_far.concat(
				reduce(
					function(alpha, output_so_far) {
						return output_so_far.concat(model(
							alpha,
							"pos_neg_null",
							prior_distribution_type,
							cost_of_adjective,
							false
						));
					},
					[],
					alphas
				)
			)
		}, [], costs_of_adjective)
	);

	simpleCSV.writeCSV(model_output, "data/output/" + version + "_priors/" + prior_distribution_type + '.csv');
}, prior_distribution_types)

// var model_output = [["value", "theta", "probability", "alternatives", "prior_distribution", "cost_of_adjective", "utterance", "speaker_lambda"]].concat(
// 	reduce(
// 		function(prior_distribution_type, output_so_far) {
// 			return output_so_far.concat(model(1, "pos_neg_null", prior_distribution_type, 1, false));
// 		},
// 		[],
// 		prior_distribution_types
// 	)
// );

// simpleCSV.writeCSV(model_output, 'adjectives_output.csv');

"finished!";